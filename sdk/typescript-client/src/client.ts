// Auto-generated TypeScript API client
// Do not edit this file directly

import * as types from './types';

export const CLIENT_COMPAT_VERSION = '1';

/**
 * Typed event handler for log streams
 */
export class LogStream {
  private ws: WebSocket;
  private listeners: {
    log: ((item: types.LogStreamItem) => void)[];
    error: ((error: Error) => void)[];
    close: (() => void)[];
  } = {
    log: [],
    error: [],
    close: [],
  };

  constructor(ws: WebSocket) {
    this.ws = ws;

    this.ws.addEventListener('message', (event) => {
      try {
        const data = typeof event.data === 'string' ? event.data : event.data.toString();
        const logItem = convertFromApiFormat(JSON.parse(data)) as types.LogStreamItem;
        this.listeners.log.forEach(fn => fn(logItem));
      } catch (err) {
        const error = err instanceof Error ? err : new Error(String(err));
        this.listeners.error.forEach(fn => fn(error));
      }
    });

    this.ws.addEventListener('error', (event) => {
      const error = new Error('WebSocket error');
      this.listeners.error.forEach(fn => fn(error));
    });

    this.ws.addEventListener('close', () => {
      this.listeners.close.forEach(fn => fn());
    });
  }

  on(event: 'log', handler: (item: types.LogStreamItem) => void): this;
  on(event: 'error', handler: (error: Error) => void): this;
  on(event: 'close', handler: () => void): this;
  on(event: string, handler: any): this {
    if (event in this.listeners) {
      (this.listeners as any)[event].push(handler);
    }
    return this;
  }

  off(event: 'log', handler: (item: types.LogStreamItem) => void): this;
  off(event: 'error', handler: (error: Error) => void): this;
  off(event: 'close', handler: () => void): this;
  off(event: string, handler: any): this {
    if (event in this.listeners) {
      const handlers = (this.listeners as any)[event];
      const index = handlers.indexOf(handler);
      if (index !== -1) {
        handlers.splice(index, 1);
      }
    }
    return this;
  }

  close(): void {
    this.ws.close();
  }

  get readyState(): number {
    return this.ws.readyState;
  }
}

/**
 * Map of type names to fields that contain user-defined data
 * and should not have their contents recursively converted.
 * Generated from schema fields marked with !sdk:skip-formatting
 */
const SKIP_FORMATTING_FIELDS: Record<string, Set<string>> = {
  'AppV1': new Set(['environment']),
  'MachineV1': new Set(['environment']),
};

/**
 * Converts TypeScript format (underscore properties) to API format (hyphenated properties)
 * Used for sending requests to the API.
 * @param obj The object to convert
 * @param depth Current traversal depth (relative to the typed object)
 * @param typeName Optional type name for checking skip-formatting fields
 */
function convertToApiFormat(obj: any, depth: number = 0, typeName?: string): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(item => convertToApiFormat(item, depth + 1, typeName));
  }

  if (typeof obj === 'object' && obj.constructor === Object) {
    const result: any = {};
    const skipFields = typeName ? SKIP_FORMATTING_FIELDS[typeName] : undefined;

    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const apiKey = key.replace(/_/g, '-');
        // Don't recursively convert fields marked with !sdk:skip-formatting
        if (depth === 0 && skipFields?.has(key)) {
          result[apiKey] = obj[key];
        } else {
          result[apiKey] = convertToApiFormat(obj[key], depth + 1, typeName);
        }
      }
    }
    return result;
  }

  return obj;
}

/**
 * Converts API response format (hyphenated properties) to TypeScript (underscore properties)
 * Used for generic response handling.
 * @param obj The object to convert
 * @param depth Current traversal depth (relative to the typed object)
 * @param typeName Optional type name for checking skip-formatting fields
 */
function convertFromApiFormat(obj: any, depth: number = 0, typeName?: string): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(item => convertFromApiFormat(item, depth + 1, typeName));
  }

  if (typeof obj === 'object' && obj.constructor === Object) {
    const result: any = {};
    const skipFields = typeName ? SKIP_FORMATTING_FIELDS[typeName] : undefined;

    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const tsKey = key.replace(/-/g, '_');
        // Don't recursively convert fields marked with !sdk:skip-formatting
        if (depth === 0 && skipFields?.has(tsKey)) {
          result[tsKey] = obj[key];
        } else {
          result[tsKey] = convertFromApiFormat(obj[key], depth + 1, typeName);
        }
      }
    }
    return result;
  }

  return obj;
}

export interface ApiClientConfig {
  baseUrl: string;
  token: string;
  fetch?: typeof fetch;
  WebSocket?: typeof WebSocket;
}

export type NamespaceParam = string | null;

export class ApiClient {
  private config: ApiClientConfig;
  private fetchFn: typeof fetch;
  private WebSocketImpl: typeof WebSocket;

  constructor(config: ApiClientConfig) {
    this.config = config;
    this.fetchFn = config.fetch || fetch;
    this.WebSocketImpl = config.WebSocket || WebSocket;
  }

  core(): CoreApiClient {
    return new CoreApiClient(this.config, this.fetchFn, this.WebSocketImpl);
  }

  gadget(): GadgetApiClient {
    return new GadgetApiClient(this.config, this.fetchFn, this.WebSocketImpl);
  }

  app(): AppApiClient {
    return new AppApiClient(this.config, this.fetchFn, this.WebSocketImpl);
  }

  machine(): MachineApiClient {
    return new MachineApiClient(this.config, this.fetchFn, this.WebSocketImpl);
  }

  service(): ServiceApiClient {
    return new ServiceApiClient(this.config, this.fetchFn, this.WebSocketImpl);
  }

  certificate(): CertificateApiClient {
    return new CertificateApiClient(this.config, this.fetchFn, this.WebSocketImpl);
  }

  volume(): VolumeApiClient {
    return new VolumeApiClient(this.config, this.fetchFn, this.WebSocketImpl);
  }

}

export class CoreApiClient {
  private config: ApiClientConfig;
  private fetchFn: typeof fetch;
  private WebSocketImpl: typeof WebSocket;

  constructor(config: ApiClientConfig, fetchFn: typeof fetch, WebSocketImpl: typeof WebSocket) {
    this.config = config;
    this.fetchFn = fetchFn;
    this.WebSocketImpl = WebSocketImpl;
  }

  async me(): Promise<types.Me> {
    const url = `${this.config.baseUrl}/core/me`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return convertFromApiFormat(data);
  }

  async get_registry_robot(): Promise<types.RegistryRobot> {
    const url = `${this.config.baseUrl}/core/registry/robot`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return convertFromApiFormat(data);
  }

  async get_registry_builder_robot(): Promise<types.RegistryRobot> {
    const url = `${this.config.baseUrl}/core/registry/builder-robot`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return convertFromApiFormat(data);
  }

  async list_namespaces(): Promise<types.ListNamespaces> {
    const url = `${this.config.baseUrl}/core/namespaces`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return convertFromApiFormat(data);
  }

  async delete_namespace(deleteNamespaceParams: types.DeleteNamespaceParams): Promise<types.DeleteNamespaceResponse> {
    const url = `${this.config.baseUrl}/core/namespaces/delete`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    const options: RequestInit = {
      method: 'PUT',
      headers,
      body: JSON.stringify(deleteNamespaceParams),
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return convertFromApiFormat(data);
  }

  stream_logs(namespace: NamespaceParam, logStreamParams: types.LogStreamParams): LogStream {
    const wsUrl = this.config.baseUrl.replace(/^http/, 'ws');
    let url = `${wsUrl}/core/logs`;
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(logStreamParams)) {
      if (value != null) {
        params.set(key, String(value));
      }
    }
    const queryString = params.toString();
    if (queryString) {
      url += `?${queryString}`;
    }

    const ws = new this.WebSocketImpl(url, {
      headers: {
        'x-ignition-token': this.config.token,
        'x-ignition-compat': CLIENT_COMPAT_VERSION,
        ...(namespace !== null ? { 'x-ignition-namespace': namespace } : {}),
      },
    } as any);

    return new LogStream(ws);
  }

  exec(namespace: NamespaceParam, execParams: types.ExecParams): WebSocket {
    const wsUrl = this.config.baseUrl.replace(/^http/, 'ws');
    let url = `${wsUrl}/core/exec`;
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(execParams)) {
      if (value != null) {
        params.set(key, String(value));
      }
    }
    const queryString = params.toString();
    if (queryString) {
      url += `?${queryString}`;
    }

    const ws = new this.WebSocketImpl(url, {
      headers: {
        'x-ignition-token': this.config.token,
        'x-ignition-compat': CLIENT_COMPAT_VERSION,
        ...(namespace !== null ? { 'x-ignition-namespace': namespace } : {}),
      },
    } as any);

    return ws;
  }

  async query(queryParams: types.QueryParams): Promise<types.QueryResponse> {
    const url = `${this.config.baseUrl}/core/query`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    const options: RequestInit = {
      method: 'PUT',
      headers,
      body: JSON.stringify(queryParams),
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return convertFromApiFormat(data);
  }

  async alloc_builder(): Promise<types.AllocatedBuilder> {
    const url = `${this.config.baseUrl}/core/build/alloc`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    const options: RequestInit = {
      method: 'PUT',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return convertFromApiFormat(data);
  }

}

export class GadgetApiClient {
  private config: ApiClientConfig;
  private fetchFn: typeof fetch;
  private WebSocketImpl: typeof WebSocket;

  constructor(config: ApiClientConfig, fetchFn: typeof fetch, WebSocketImpl: typeof WebSocket) {
    this.config = config;
    this.fetchFn = fetchFn;
    this.WebSocketImpl = WebSocketImpl;
  }

  async run_init(gadgetInitRunParams: types.GadgetInitRunParams): Promise<types.GadgetInitRunResponse> {
    const url = `${this.config.baseUrl}/gadget/run/init`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    const options: RequestInit = {
      method: 'PUT',
      headers,
      body: JSON.stringify(gadgetInitRunParams),
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return convertFromApiFormat(data);
  }

}

export class AppApiClient {
  private config: ApiClientConfig;
  private fetchFn: typeof fetch;
  private WebSocketImpl: typeof WebSocket;

  constructor(config: ApiClientConfig, fetchFn: typeof fetch, WebSocketImpl: typeof WebSocket) {
    this.config = config;
    this.fetchFn = fetchFn;
    this.WebSocketImpl = WebSocketImpl;
  }

  async get(namespace: string, name: string): Promise<[types.AppV1, types.AppStatus]> {
    const url = `${this.config.baseUrl}/app/${name}`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return [convertFromApiFormat(data[0], 0, 'AppV1'), convertFromApiFormat(data[1])];
  }

  async list(namespace: NamespaceParam): Promise<[types.AppV1, types.AppStatus][]> {
    const url = `${this.config.baseUrl}/app`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    if (namespace !== null) {
      headers['x-ignition-namespace'] = namespace;
    }

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return data.map((item: any) => [convertFromApiFormat(item[0], 0, 'AppV1'), convertFromApiFormat(item[1])]);
  }

  async delete(namespace: string, name: string): Promise<void> {
    const url = `${this.config.baseUrl}/app/${name}`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'DELETE',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    return;
  }

  async apply(app: types.App): Promise<void> {
    const url = `${this.config.baseUrl}/app`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    const options: RequestInit = {
      method: 'PUT',
      headers,
      body: JSON.stringify({ 'app.v1': convertToApiFormat(app['app.v1'], 0, 'AppV1') }),
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    return;
  }

  async get_status(namespace: string, name: string): Promise<types.AppStatus> {
    const url = `${this.config.baseUrl}/app/${name}/status`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return convertFromApiFormat(data);
  }

}

export class MachineApiClient {
  private config: ApiClientConfig;
  private fetchFn: typeof fetch;
  private WebSocketImpl: typeof WebSocket;

  constructor(config: ApiClientConfig, fetchFn: typeof fetch, WebSocketImpl: typeof WebSocket) {
    this.config = config;
    this.fetchFn = fetchFn;
    this.WebSocketImpl = WebSocketImpl;
  }

  async get(namespace: string, name: string): Promise<[types.MachineV1, types.MachineStatus]> {
    const url = `${this.config.baseUrl}/machine/${name}`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return [convertFromApiFormat(data[0], 0, 'MachineV1'), convertFromApiFormat(data[1])];
  }

  async list(namespace: NamespaceParam): Promise<[types.MachineV1, types.MachineStatus][]> {
    const url = `${this.config.baseUrl}/machine`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    if (namespace !== null) {
      headers['x-ignition-namespace'] = namespace;
    }

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return data.map((item: any) => [convertFromApiFormat(item[0], 0, 'MachineV1'), convertFromApiFormat(item[1])]);
  }

  async delete(namespace: string, name: string): Promise<void> {
    const url = `${this.config.baseUrl}/machine/${name}`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'DELETE',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    return;
  }

  async apply(machine: types.Machine): Promise<void> {
    const url = `${this.config.baseUrl}/machine`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    const options: RequestInit = {
      method: 'PUT',
      headers,
      body: JSON.stringify({ 'machine.v1': convertToApiFormat(machine['machine.v1'], 0, 'MachineV1') }),
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    return;
  }

  async get_status(namespace: string, name: string): Promise<types.MachineStatus> {
    const url = `${this.config.baseUrl}/machine/${name}/status`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return convertFromApiFormat(data);
  }

}

export class ServiceApiClient {
  private config: ApiClientConfig;
  private fetchFn: typeof fetch;
  private WebSocketImpl: typeof WebSocket;

  constructor(config: ApiClientConfig, fetchFn: typeof fetch, WebSocketImpl: typeof WebSocket) {
    this.config = config;
    this.fetchFn = fetchFn;
    this.WebSocketImpl = WebSocketImpl;
  }

  async get(namespace: string, name: string): Promise<[types.ServiceV1, types.ServiceStatus]> {
    const url = `${this.config.baseUrl}/service/${name}`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return [convertFromApiFormat(data[0], 0, 'ServiceV1'), convertFromApiFormat(data[1])];
  }

  async list(namespace: NamespaceParam): Promise<[types.ServiceV1, types.ServiceStatus][]> {
    const url = `${this.config.baseUrl}/service`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    if (namespace !== null) {
      headers['x-ignition-namespace'] = namespace;
    }

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return data.map((item: any) => [convertFromApiFormat(item[0], 0, 'ServiceV1'), convertFromApiFormat(item[1])]);
  }

  async delete(namespace: string, name: string): Promise<void> {
    const url = `${this.config.baseUrl}/service/${name}`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'DELETE',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    return;
  }

  async apply(service: types.Service): Promise<void> {
    const url = `${this.config.baseUrl}/service`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    const options: RequestInit = {
      method: 'PUT',
      headers,
      body: JSON.stringify({ 'service.v1': convertToApiFormat(service['service.v1'], 0, 'ServiceV1') }),
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    return;
  }

  async get_status(namespace: string, name: string): Promise<types.ServiceStatus> {
    const url = `${this.config.baseUrl}/service/${name}/status`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return convertFromApiFormat(data);
  }

}

export class CertificateApiClient {
  private config: ApiClientConfig;
  private fetchFn: typeof fetch;
  private WebSocketImpl: typeof WebSocket;

  constructor(config: ApiClientConfig, fetchFn: typeof fetch, WebSocketImpl: typeof WebSocket) {
    this.config = config;
    this.fetchFn = fetchFn;
    this.WebSocketImpl = WebSocketImpl;
  }

  async get(namespace: string, name: string): Promise<[types.CertificateV1, types.CertificateStatus]> {
    const url = `${this.config.baseUrl}/certificate/${name}`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return [convertFromApiFormat(data[0], 0, 'CertificateV1'), convertFromApiFormat(data[1])];
  }

  async list(namespace: NamespaceParam): Promise<[types.CertificateV1, types.CertificateStatus][]> {
    const url = `${this.config.baseUrl}/certificate`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    if (namespace !== null) {
      headers['x-ignition-namespace'] = namespace;
    }

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return data.map((item: any) => [convertFromApiFormat(item[0], 0, 'CertificateV1'), convertFromApiFormat(item[1])]);
  }

  async delete(namespace: string, name: string): Promise<void> {
    const url = `${this.config.baseUrl}/certificate/${name}`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'DELETE',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    return;
  }

  async apply(certificate: types.Certificate): Promise<void> {
    const url = `${this.config.baseUrl}/certificate`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    const options: RequestInit = {
      method: 'PUT',
      headers,
      body: JSON.stringify({ 'certificate.v1': convertToApiFormat(certificate['certificate.v1'], 0, 'CertificateV1') }),
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    return;
  }

  async get_status(namespace: string, name: string): Promise<types.CertificateStatus> {
    const url = `${this.config.baseUrl}/certificate/${name}/status`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return convertFromApiFormat(data);
  }

}

export class VolumeApiClient {
  private config: ApiClientConfig;
  private fetchFn: typeof fetch;
  private WebSocketImpl: typeof WebSocket;

  constructor(config: ApiClientConfig, fetchFn: typeof fetch, WebSocketImpl: typeof WebSocket) {
    this.config = config;
    this.fetchFn = fetchFn;
    this.WebSocketImpl = WebSocketImpl;
  }

  async get(namespace: string, name: string): Promise<[types.VolumeV1, types.VolumeStatus]> {
    const url = `${this.config.baseUrl}/volume/${name}`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return [convertFromApiFormat(data[0], 0, 'VolumeV1'), convertFromApiFormat(data[1])];
  }

  async list(namespace: NamespaceParam): Promise<[types.VolumeV1, types.VolumeStatus][]> {
    const url = `${this.config.baseUrl}/volume`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    if (namespace !== null) {
      headers['x-ignition-namespace'] = namespace;
    }

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return data.map((item: any) => [convertFromApiFormat(item[0], 0, 'VolumeV1'), convertFromApiFormat(item[1])]);
  }

  async delete(namespace: string, name: string): Promise<void> {
    const url = `${this.config.baseUrl}/volume/${name}`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'DELETE',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    return;
  }

  async apply(volume: types.Volume): Promise<void> {
    const url = `${this.config.baseUrl}/volume`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    const options: RequestInit = {
      method: 'PUT',
      headers,
      body: JSON.stringify({ 'volume.v1': convertToApiFormat(volume['volume.v1'], 0, 'VolumeV1') }),
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    return;
  }

  async get_status(namespace: string, name: string): Promise<types.VolumeStatus> {
    const url = `${this.config.baseUrl}/volume/${name}/status`;
    const headers: Record<string, string> = {
      'x-ignition-token': this.config.token,
      'x-ignition-compat': CLIENT_COMPAT_VERSION,
      'Content-Type': 'application/json',
    };

    headers['x-ignition-namespace'] = namespace;

    const options: RequestInit = {
      method: 'GET',
      headers,
    };

    const response = await this.fetchFn(url, options);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`API error: ${response.status} ${text}`);
    }

    const data = await response.json();
    return convertFromApiFormat(data);
  }

}

