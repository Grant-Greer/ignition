// Auto-generated TypeScript types from JSON Schema
// Do not edit this file directly

export interface AllocatedBuilder {
  host: string;
  client_cert_pem: string;
  client_key_pem: string;
  ca_cert_pem: string;
}

export type App = { 'app.v1': AppV1 };

export interface AppAllocatedService {
  name: string;
  hash: number;
  domain?: string | null;
}

export interface AppExpose {
  port: number;
  connection_tracking?: (ServiceTargetConnectionTracking | null);
  external?: (AppExposeExternal | null);
  internal?: (AppExposeInternal | null);
}

export interface AppExposeExternal {
  host?: string | null;
  port?: number | null;
  protocol: ServiceBindExternalProtocol;
}

export interface AppExposeInternal {
  port?: number | null;
}

export interface AppStatus {
  machine_hash: number;
  machine_name?: string | null;
  allocated_services: Record<string, AppAllocatedService>;
}

export interface AppV1 {
  tags?: string[] | null;
  namespace?: string | null;
  name: string;
  image?: string | null;
  build?: (MachineBuild | null);
  resources: MachineResources;
  restart_policy?: (MachineRestartPolicy | null);
  mode?: (MachineMode | null);
  volumes?: MachineVolumeBinding[] | null;
  command?: string[] | null;
  /** !sdk:skip-formatting */
  environment?: Record<string, string> | null;
  depends_on?: MachineDependency[] | null;
  expose?: Record<string, AppExpose> | null;
}

export type Certificate = { 'certificate.v1': CertificateV1 };

export type CertificateIssuer = { auto: { provider: string, email?: string | null, renewal?: (CertificateRenewalConfig | null) } } | { manual: { cert_path: string, key_path: string, ca_path?: string | null } };

export interface CertificateRenewalConfig {
  /** Days before expiry to start renewal attempts. Default: 30 days. */
  days_before_expiry?: number | null;
  /** Hours between renewal retry attempts on failure. Default: 12 hours. */
  retry_interval_hours?: number | null;
}

export type CertificateState = "pending" | "pending-acme-account" | "pending-dns-resolution" | "ready" | "renewing" | "failed" | "expired" | "revoked" | { pending_order: string | null } | { pending_challenge: string } | { validating: string } | { issuing: string };

export interface CertificateStatus {
  state: CertificateState;
  not_before?: string | null;
  not_after?: string | null;
  last_failure_reason?: string | null;
  renewal_time?: string | null;
  domains: string[];
  auto_provider_name?: string | null;
}

export interface CertificateV1 {
  tags?: string[] | null;
  namespace?: string | null;
  name: string;
  domains: string[];
  issuer: CertificateIssuer;
}

export interface DeleteNamespaceParams {
  namespace: string;
  confirm: boolean;
}

export interface DeleteNamespaceResponse {
  resources: DeletedResource[];
  did_delete: boolean;
}

export interface DeletedResource {
  kind: string;
  name: string;
}

export interface ExecParams {
  machine_name: string;
  command: string;
  stdin?: boolean | null;
  tty?: boolean | null;
}

export interface GadgetInitRunParams {
  discovery_data: GadgetInitDiscoveryData;
  reasoning_effort?: (GadgetInitReasoningEffort | null);
  messages: GadgetClientMessage[];
}

export interface BuildPlanPhase {
  name: string;
  build_info: string;
}

export interface DirBuildPlan {
  detected_providers: string[];
  phases: BuildPlanPhase[];
}

export interface DirBuildPlanArgs {
  /** Path of the directory to attempt to build (relative to root directory) */
  path: string;
}

export interface GadgetClientMessage {
  service_message: GadgetServiceMessage;
  client_reply?: (GadgetClientReply | null);
}

export type GadgetClientReply = { ReadFile: ReadFileResult } | { ListDir: ListDirResult } | { DirBuildPlan: DirBuildPlan } | { Error: string };

export interface GadgetInitData {
  plan: InitPlan;
}

export interface GadgetInitDiscoveryData {
  base_dir_name: string;
  base_dir_build_plan: DirBuildPlan;
}

export type GadgetInitReasoningEffort = "Minimal" | "Low" | "Medium" | "High";

export type GadgetServiceMessage = { ReadFile: ReadFileArgs } | { ListDir: ListDirArgs } | { DirBuildPlan: DirBuildPlanArgs } | { Finish: GadgetInitData } | { Error: string };

export interface InitApp {
  name: string;
  namespace?: string | null;
  source: InitAppSource;
  snapshot_strategy?: (InitAppSnapshotStrategy | null);
  envs?: InitAppEnv[] | null;
  /** Services that this app depends on */
  depends_on?: InitAppDependsOn[] | null;
  exposed_ports?: InitAppExposedPort[] | null;
  binded_volumes?: InitAppBindedVolume[] | null;
}

export interface InitAppBindedVolume {
  name: string;
  namespace?: string | null;
  /** Path of the volume inside the container */
  path: string;
}

export interface InitAppBuildAuto {
  /** Path of the directory to build (relative to root directory) */
  dir_path?: string | null;
  /** Extra files to ignore (relative to root directory) */
  append_docker_ignore_extra?: (InitAppendDockerIgnoreExtra | null);
}

export interface InitAppBuildDockerfile {
  /** Path of the Dockerfile to build (relative to root directory) */
  dir_path: string;
  /** Name of the Dockerfile to use (relative to root directory) (default: Dockerfile) */
  dockerfile_name?: string | null;
  /** Extra files to ignore (relative to root directory) */
  append_docker_ignore_extra?: (InitAppendDockerIgnoreExtra | null);
}

export interface InitAppDependsOn {
  name: string;
  namespace?: string | null;
}

export interface InitAppEnv {
  name: string;
  value: InitAppEnvValue;
}

export type InitAppEnvValue = { Literal: string } | { Expression: string } | { CopyFromEnvFile: { var_name: string } };

export interface InitAppExposedPort {
  name: string;
  /** Port inside the container */
  port: number;
  mode: InitAppExposedPortMode;
}

export type InitAppExposedPortMode = { Internal: { protocol: InitAppExposedPortProtocolInternal } } | { External: { protocol: InitAppExposedPortProtocolExternal } };

export type InitAppExposedPortProtocolExternal = "Tls" | "Https";

export type InitAppExposedPortProtocolInternal = "Tcp";

export interface InitAppImage {
  image: string;
}

export type InitAppSnapshotStrategy = "SuspendBeforeStart" | "SuspendAfterListenOnAnyPort" | "SuspendManually" | { SuspendAfterListenOnPort: number };

export type InitAppSource = { BuildAutomatically: InitAppBuildAuto } | { BuildWithDockerfile: InitAppBuildDockerfile } | { Image: InitAppImage };

export interface InitAppendDockerIgnoreExtra {
  /** Path of the file to append to (relative to root directory) */
  path: string;
  lines: string[];
}

export interface InitIssue {
  message: string;
}

export interface InitPlan {
  apps: InitApp[];
  volumes: InitVolume[];
  issues: InitIssue[];
  warnings: InitWarning[];
}

export interface InitVolume {
  name: string;
  namespace?: string | null;
}

export interface InitWarning {
  message: string;
}

export interface ListDirArgs {
  /** Path of the file or directory to list (relative to root directory) */
  path: string;
  max_depth?: number | null;
}

export interface ListDirItem {
  /** Path of the file or directory (relative to root directory) */
  path: string;
  is_dir: boolean;
  size: number;
}

export interface ListDirResult {
  items: ListDirItem[];
}

export interface ReadFileArgs {
  /** Paths of the file to read (relative to root directory) */
  path: string;
}

export interface ReadFileResult {
  /** Path of the file (relative to root directory) */
  path: string;
  content: string;
}

export interface GadgetInitRunResponse {
  messages: GadgetServiceMessage[];
}

export interface ListNamespaces {
  namespaces: Namespace[];
}

export interface Namespace {
  name: string;
  created_at: number;
}

export interface LogStreamItem {
  timestamp: number;
  message: string;
  target_stream: LogStreamTarget;
}

export type LogStreamTarget = "stdout" | "stderr";

export type LogStreamParams = { machine_name: string, start_ts_ns?: string | null, end_ts_ns?: string | null } | { group_name: string, start_ts_ns?: string | null, end_ts_ns?: string | null };

export type Machine = { 'machine.v1': MachineV1 };

export type MachineBuild = "auto";

export interface MachineBuildOptions {
  name?: string | null;
  tag?: string | null;
  image?: string | null;
  dir?: string | null;
}

export interface MachineDependency {
  name: string;
  namespace?: string | null;
}

export interface MachineDockerOptions {
  name?: string | null;
  tag?: string | null;
  image?: string | null;
  context?: string | null;
  dockerfile?: string | null;
  args?: Record<string, string> | null;
}

export type MachineMode = "regular" | { flash: { strategy: MachineSnapshotStrategy, timeout?: number | null } };

export type MachinePhase = "idle" | "pulling-image" | "waiting" | "creating" | "booting" | "ready" | "suspending" | "suspended" | "stopping" | "stopped" | "restarting" | { error: { message: string } };

export interface MachineResources {
  cpu: number;
  memory: number;
}

export type MachineRestartPolicy = "never" | "always" | "on-failure" | "remove";

export type MachineSnapshotStrategy = "first-listen" | "user-space-ready" | "manual" | { nth_listen: number } | { listen_on_port: number };

export interface MachineStatus {
  hash: number;
  phase: MachinePhase;
  image_id?: string | null;
  image_resolved_reference?: string | null;
  machine_id?: string | null;
  machine_ip?: string | null;
  machine_tap?: string | null;
  machine_image_volume_id?: string | null;
  last_boot_time_us?: number | null;
  first_boot_time_us?: number | null;
  last_restarting_time_us?: number | null;
  last_exit_code?: number | null;
}

export interface MachineV1 {
  tags?: string[] | null;
  namespace?: string | null;
  name: string;
  image?: string | null;
  build?: (MachineBuild | null);
  resources: MachineResources;
  restart_policy?: (MachineRestartPolicy | null);
  mode?: (MachineMode | null);
  volumes?: MachineVolumeBinding[] | null;
  command?: string[] | null;
  /** !sdk:skip-formatting */
  environment?: Record<string, string> | null;
  depends_on?: MachineDependency[] | null;
}

export interface MachineVolumeBinding {
  name: string;
  namespace?: string | null;
  path: string;
}

export interface Me {
  tenant: string;
  sub: string;
}

export interface Namespace {
  name: string;
  created_at: number;
}

export interface QueryParams {
  query: string;
  env: Record<string, string>;
  var: Record<string, any>;
  git?: (QueryGitInfo | null);
  lttle_profile: string;
}

export interface QueryGitInfo {
  branch?: string | null;
  commit_sha: string;
  commit_message: string;
  tag?: string | null;
  latest_tag?: string | null;
  ref: string;
}

export interface QueryResponse {
  query_result: any;
}

export interface RegistryRobot {
  registry: string;
  user: string;
  pass: string;
}

export type Service = { 'service.v1': ServiceV1 };

export type ServiceBind = { internal: { port?: number | null } } | { external: { host: string, port?: number | null, protocol: ServiceBindExternalProtocol } };

export type ServiceBindExternalProtocol = "http" | "https" | "tls";

export interface ServiceStatus {
  service_ip?: string | null;
  internal_dns_hostname?: string | null;
}

export interface ServiceTarget {
  name: string;
  namespace?: string | null;
  port: number;
  protocol: ServiceTargetProtocol;
  connection_tracking?: (ServiceTargetConnectionTracking | null);
}

export type ServiceTargetConnectionTracking = "connection-aware" | { traffic_aware: { inactivity_timeout?: number | null } };

export type ServiceTargetProtocol = "http" | "tcp";

export interface ServiceV1 {
  tags?: string[] | null;
  namespace?: string | null;
  name: string;
  target: ServiceTarget;
  bind: ServiceBind;
}

export type Volume = { 'volume.v1': VolumeV1 };

export type VolumeMode = "read-only" | "writeable";

export interface VolumeStatus {
  hash: number;
  volume_id?: string | null;
  size_bytes: number;
}

export interface VolumeV1 {
  tags?: string[] | null;
  namespace?: string | null;
  name: string;
  mode: VolumeMode;
  /** The size of the volume in human readable format */
  size: string;
}

