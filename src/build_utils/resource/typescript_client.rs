use anyhow::Result;
use serde_json::{Map, Value};
use std::collections::HashSet;

use crate::{
    build_utils::{cargo, fs::write_if_changed},
    machinery::api_schema::{
        ApiMethod, ApiPathSegment, ApiRequest, ApiResponse, ApiSchema, ApiVerb,
    },
};

pub async fn build_typescript_api_client(api_schema: &ApiSchema) -> Result<()> {
    let client_out_dir = cargo::workspace_root_dir_path("sdk/typescript-client/src").await?;
    std::fs::create_dir_all(&client_out_dir)?;

    // Generate types from JSON Schema
    let types_src = generate_types_from_schema(api_schema)?;
    let types_out_path = client_out_dir.join("types.ts");
    write_if_changed(&types_out_path, types_src).await?;

    // Generate API client
    let client_src = generate_client(api_schema)?;
    let client_out_path = client_out_dir.join("client.ts");
    write_if_changed(&client_out_path, client_src).await?;

    // Generate index file
    let index_src = generate_index();
    let index_out_path = client_out_dir.join("index.ts");
    write_if_changed(&index_out_path, index_src).await?;

    // Sync version from Cargo.toml to package.json
    update_package_json_version().await?;

    Ok(())
}

async fn update_package_json_version() -> Result<()> {
    let package_json_path =
        cargo::workspace_root_dir_path("sdk/typescript-client/package.json").await?;
    let package_json_content = std::fs::read_to_string(&package_json_path)?;

    // Parse package.json
    let mut package_json: serde_json::Value = serde_json::from_str(&package_json_content)?;

    // Get version from Cargo env
    let cargo_version = env!("CARGO_PKG_VERSION");

    // Update version if different
    if let Some(current_version) = package_json.get("version").and_then(|v| v.as_str()) {
        if current_version != cargo_version {
            package_json["version"] = serde_json::Value::String(cargo_version.to_string());

            // Write back with pretty formatting
            let updated_content = serde_json::to_string_pretty(&package_json)?;
            write_if_changed(&package_json_path, format!("{}\n", updated_content)).await?;
        }
    }

    Ok(())
}

fn generate_index() -> String {
    let mut src = String::new();
    src.push_str("// Auto-generated TypeScript API client\n");
    src.push_str("// Do not edit this file directly\n\n");
    src.push_str("export * from './types';\n");
    src.push_str("export * from './client';\n");
    src
}

fn generate_types_from_schema(api_schema: &ApiSchema) -> Result<String> {
    let mut src = String::new();
    src.push_str("// Auto-generated TypeScript types from JSON Schema\n");
    src.push_str("// Do not edit this file directly\n\n");

    let mut types_to_generate = HashSet::new();

    // Collect root types referenced by API methods
    for service in &api_schema.services {
        for method in &service.methods {
            // Collect request types
            if let Some(request) = &method.request {
                match request {
                    ApiRequest::SchemaDefinition { name }
                    | ApiRequest::OptionalSchemaDefinition { name }
                    | ApiRequest::TaggedSchemaDefinition { name, .. } => {
                        types_to_generate.insert(name.clone());
                    }
                }
            }

            // Collect response types
            if let Some(response) = &method.response {
                let names = match response {
                    ApiResponse::SchemaDefinition { name, .. } => vec![name.clone()],
                    ApiResponse::TupleSchemaDefinition { names, .. } => names.clone(),
                    ApiResponse::RawSocket => vec![],
                };

                for name in names {
                    types_to_generate.insert(name);
                }
            }
        }
    }

    // Recursively collect all dependent types
    let mut all_types = HashSet::new();
    let mut queue: Vec<String> = types_to_generate.into_iter().collect();

    while let Some(type_name) = queue.pop() {
        if all_types.contains(&type_name) {
            continue;
        }

        all_types.insert(type_name.clone());

        // Find all $ref dependencies in this type's schema
        if let Some(schema) = api_schema.defs.get(&type_name) {
            let deps = collect_type_dependencies(schema);
            for dep in deps {
                if !all_types.contains(&dep) {
                    queue.push(dep);
                }
            }
        }
    }

    // Sort types for consistent output
    let mut sorted_types: Vec<String> = all_types.into_iter().collect();
    sorted_types.sort();

    // Collect all nested types first to avoid duplicates
    let mut all_nested_types = HashSet::new();
    for type_name in &sorted_types {
        if let Some(schema) = api_schema.defs.get(type_name) {
            if let Some(nested_defs) = schema.get("$defs") {
                if let Some(nested_obj) = nested_defs.as_object() {
                    for nested_type_name in nested_obj.keys() {
                        all_nested_types.insert(nested_type_name.clone());
                    }
                }
            }
        }
    }

    // Generate all types
    let type_generator = TypeGenerator::new(&api_schema.defs);
    let mut generated_nested = HashSet::new();

    for type_name in sorted_types {
        if let Some(type_def) = type_generator.generate_type(&type_name, &api_schema.defs)? {
            src.push_str(&type_def);
            src.push_str("\n\n");
        }

        // Also generate nested $defs if they exist (avoiding duplicates)
        if let Some(schema) = api_schema.defs.get(&type_name) {
            if let Some(nested_defs) = schema.get("$defs") {
                if let Some(nested_obj) = nested_defs.as_object() {
                    let mut nested_types: Vec<String> = nested_obj.keys().cloned().collect();
                    nested_types.sort();

                    for nested_type_name in nested_types {
                        if !generated_nested.contains(&nested_type_name) {
                            generated_nested.insert(nested_type_name.clone());
                            if let Some(nested_schema) = nested_obj.get(&nested_type_name) {
                                let mut nested_src = String::new();
                                type_generator.generate_type_from_schema(
                                    &nested_type_name,
                                    nested_schema,
                                    &mut nested_src,
                                    &api_schema.defs,
                                )?;
                                src.push_str(&nested_src);
                                src.push_str("\n\n");
                            }
                        }
                    }
                }
            }
        }
    }

    Ok(src)
}

fn collect_type_dependencies(schema: &Value) -> Vec<String> {
    let mut deps = Vec::new();
    collect_refs_recursive(schema, &mut deps);
    deps
}

fn collect_refs_recursive(value: &Value, deps: &mut Vec<String>) {
    match value {
        Value::Object(obj) => {
            // Check if this object has a $ref
            if let Some(ref_value) = obj.get("$ref") {
                if let Some(ref_str) = ref_value.as_str() {
                    if let Some(type_name) = ref_str.strip_prefix("#/$defs/") {
                        deps.push(type_name.to_string());
                    }
                }
            }

            // Recursively check all values in the object
            for (_, v) in obj {
                collect_refs_recursive(v, deps);
            }
        }
        Value::Array(arr) => {
            // Recursively check all items in the array
            for item in arr {
                collect_refs_recursive(item, deps);
            }
        }
        _ => {}
    }
}

struct TypeGenerator<'a> {
    #[allow(dead_code)]
    defs: &'a Map<String, Value>,
    #[allow(dead_code)]
    generating: HashSet<String>,
}

impl<'a> TypeGenerator<'a> {
    fn new(defs: &'a Map<String, Value>) -> Self {
        Self {
            defs,
            generating: HashSet::new(),
        }
    }

    fn generate_type(&self, name: &str, defs: &Map<String, Value>) -> Result<Option<String>> {
        if let Some(schema) = defs.get(name) {
            let mut src = String::new();
            self.generate_type_from_schema(name, schema, &mut src, defs)?;
            Ok(Some(src))
        } else {
            Ok(None)
        }
    }

    fn generate_type_from_schema(
        &self,
        name: &str,
        schema: &Value,
        src: &mut String,
        defs: &Map<String, Value>,
    ) -> Result<()> {
        // Handle oneOf (union types for versioned resources and discriminated unions)
        if let Some(one_of) = schema.get("oneOf") {
            if let Some(variants) = one_of.as_array() {
                src.push_str(&format!("export type {} = ", name));
                let mut variant_types = Vec::new();

                for variant in variants {
                    // Check if this is a wrapper pattern (versioned resources or discriminated unions)
                    if let Some(props) = variant.get("properties") {
                        if let Some(obj) = props.as_object() {
                            if obj.len() == 1 {
                                let (prop_name, prop_schema) = obj.iter().next().unwrap();

                                // Check if this has a $ref (wrapper pattern)
                                if let Some(ref_path) = prop_schema.get("$ref") {
                                    if let Some(ref_str) = ref_path.as_str() {
                                        let type_name =
                                            ref_str.strip_prefix("#/$defs/").unwrap_or(ref_str);

                                        // Distinguish between resource wrappers and discriminated unions
                                        // Resource wrappers are lowercase (e.g., "app", "app.v1")
                                        // Discriminated unions have mixed case (e.g., "BuildAutomatically")
                                        let is_lowercase = prop_name
                                            .chars()
                                            .filter(|c| c.is_alphabetic())
                                            .all(|c| c.is_lowercase());

                                        if is_lowercase {
                                            // This is a resource wrapper - only include versioned ones
                                            if prop_name.contains(".v") {
                                                variant_types.push(format!(
                                                    "{{ '{}': {} }}",
                                                    prop_name, type_name
                                                ));
                                                continue;
                                            } else {
                                                // Skip non-versioned resource wrappers
                                                continue;
                                            }
                                        } else {
                                            // This is a discriminated union variant - include it
                                            variant_types.push(format!(
                                                "{{ {}: {} }}",
                                                prop_name, type_name
                                            ));
                                            continue;
                                        }
                                    }
                                }
                                // If it's not a $ref wrapper, fall through to handle as a regular object
                            }
                        }
                    }

                    // Handle string enums directly in oneOf
                    if let Some(type_val) = variant.get("type") {
                        if type_val == "string" {
                            if let Some(enum_values) = variant.get("enum") {
                                if let Some(values) = enum_values.as_array() {
                                    for value in values {
                                        if let Some(s) = value.as_str() {
                                            variant_types.push(format!("\"{}\"", s));
                                        }
                                    }
                                    continue;
                                }
                            }
                        }
                    }

                    // For inline object types, generate inline TypeScript
                    if let Some(type_val) = variant.get("type") {
                        if type_val == "object" {
                            // Generate inline object type
                            let inline_type = self.generate_inline_object_type(variant, defs)?;
                            variant_types.push(inline_type);
                            continue;
                        }
                    }

                    // Fallback: use schema_to_ts_type for any other variant
                    let ts_type = self.schema_to_ts_type(variant, defs)?;
                    if ts_type != "any" {
                        variant_types.push(ts_type);
                    }
                }

                if variant_types.is_empty() {
                    // If we couldn't extract any variants, use any with a comment
                    src.push_str("any; // Complex union type - manual definition recommended");
                } else {
                    src.push_str(&variant_types.join(" | "));
                    src.push_str(";");
                }
                return Ok(());
            }
        }

        // Handle anyOf
        if let Some(any_of) = schema.get("anyOf") {
            if let Some(variants) = any_of.as_array() {
                src.push_str(&format!("export type {} = ", name));
                let mut variant_types = Vec::new();
                for variant in variants {
                    // Check if this is an inline object type
                    if let Some(type_val) = variant.get("type") {
                        if type_val == "object" && variant.get("properties").is_some() {
                            // Generate inline object type
                            let inline_type = self.generate_inline_object_type(variant, defs)?;
                            variant_types.push(inline_type);
                            continue;
                        }
                    }
                    variant_types.push(self.schema_to_ts_type(variant, defs)?);
                }
                src.push_str(&variant_types.join(" | "));
                src.push_str(";");
                return Ok(());
            }
        }

        // Handle enum
        if let Some(enum_values) = schema.get("enum") {
            if let Some(values) = enum_values.as_array() {
                src.push_str(&format!("export type {} = ", name));
                let mut enum_strings = Vec::new();
                for value in values {
                    if let Some(s) = value.as_str() {
                        enum_strings.push(format!("\"{}\"", s));
                    }
                }
                src.push_str(&enum_strings.join(" | "));
                src.push_str(";");
                return Ok(());
            }
        }

        // Handle object type
        if let Some(type_value) = schema.get("type") {
            if type_value == "object" {
                src.push_str(&format!("export interface {} {{\n", name));

                if let Some(properties) = schema.get("properties") {
                    if let Some(props) = properties.as_object() {
                        let required_fields: HashSet<String> = schema
                            .get("required")
                            .and_then(|r| r.as_array())
                            .map(|arr| {
                                arr.iter()
                                    .filter_map(|v| v.as_str().map(String::from))
                                    .collect()
                            })
                            .unwrap_or_default();

                        for (prop_name, prop_schema) in props {
                            let is_optional = !required_fields.contains(prop_name);
                            let ts_type = self.schema_to_ts_type(prop_schema, defs)?;

                            // Add description as JSDoc comment if available
                            if let Some(description) = prop_schema.get("description") {
                                if let Some(desc_str) = description.as_str() {
                                    src.push_str(&format!("  /** {} */\n", desc_str));
                                }
                            }

                            // Convert hyphens to underscores for TypeScript property names
                            let ts_prop_name = prop_name.replace('-', "_").replace('.', "_");

                            src.push_str(&format!(
                                "  {}{}: {};\n",
                                ts_prop_name,
                                if is_optional { "?" } else { "" },
                                ts_type
                            ));
                        }
                    }
                }

                src.push_str("}");
                return Ok(());
            }
        }

        // Fallback: use any
        src.push_str(&format!("export type {} = any;", name));
        Ok(())
    }

    fn generate_inline_object_type(
        &self,
        schema: &Value,
        defs: &Map<String, Value>,
    ) -> Result<String> {
        let mut result = String::from("{ ");

        if let Some(properties) = schema.get("properties") {
            if let Some(props) = properties.as_object() {
                let required_fields: HashSet<String> = schema
                    .get("required")
                    .and_then(|r| r.as_array())
                    .map(|arr| {
                        arr.iter()
                            .filter_map(|v| v.as_str().map(String::from))
                            .collect()
                    })
                    .unwrap_or_default();

                let mut prop_strs = Vec::new();
                for (prop_name, prop_schema) in props {
                    let is_optional = !required_fields.contains(prop_name);
                    let ts_type = self.schema_to_ts_type(prop_schema, defs)?;

                    // Convert hyphens to underscores for TypeScript property names
                    let ts_prop_name = prop_name.replace('-', "_").replace('.', "_");

                    prop_strs.push(format!(
                        "{}{}: {}",
                        ts_prop_name,
                        if is_optional { "?" } else { "" },
                        ts_type
                    ));
                }

                result.push_str(&prop_strs.join(", "));
            }
        }

        result.push_str(" }");
        Ok(result)
    }

    fn schema_to_ts_type(&self, schema: &Value, defs: &Map<String, Value>) -> Result<String> {
        // Handle $ref
        if let Some(ref_path) = schema.get("$ref") {
            if let Some(ref_str) = ref_path.as_str() {
                let type_name = ref_str.strip_prefix("#/$defs/").unwrap_or(ref_str);
                return Ok(type_name.to_string());
            }
        }

        // Handle anyOf
        if let Some(any_of) = schema.get("anyOf") {
            if let Some(variants) = any_of.as_array() {
                let mut types = Vec::new();
                for variant in variants {
                    types.push(self.schema_to_ts_type(variant, defs)?);
                }
                return Ok(format!("({})", types.join(" | ")));
            }
        }

        // Handle array type
        if let Some(type_value) = schema.get("type") {
            if type_value == "array" {
                if let Some(items) = schema.get("items") {
                    let item_type = self.schema_to_ts_type(items, defs)?;
                    return Ok(format!("{}[]", item_type));
                }
                return Ok("any[]".to_string());
            }

            // Handle type arrays (e.g., ["array", "null"], ["string", "null"], ["object", "null"])
            if let Some(types) = type_value.as_array() {
                let mut ts_types = Vec::new();

                for t in types {
                    if let Some(type_str) = t.as_str() {
                        if type_str == "array" {
                            // For array types, check if items are specified
                            if let Some(items) = schema.get("items") {
                                let item_type = self.schema_to_ts_type(items, defs)?;
                                ts_types.push(format!("{}[]", item_type));
                            } else {
                                ts_types.push("any[]".to_string());
                            }
                        } else if type_str == "object" {
                            // For object types, check for properties/additionalProperties
                            if let Some(_properties) = schema.get("properties") {
                                let obj_type = self.generate_inline_object_type(schema, defs)?;
                                ts_types.push(obj_type);
                            } else if let Some(additional_props) =
                                schema.get("additionalProperties")
                            {
                                if additional_props.is_object() {
                                    let value_type =
                                        self.schema_to_ts_type(additional_props, defs)?;
                                    ts_types.push(format!("Record<string, {}>", value_type));
                                } else if additional_props.as_bool() == Some(true) {
                                    ts_types.push("Record<string, any>".to_string());
                                } else {
                                    ts_types.push(json_type_to_ts(type_str));
                                }
                            } else {
                                ts_types.push(json_type_to_ts(type_str));
                            }
                        } else {
                            ts_types.push(json_type_to_ts(type_str));
                        }
                    }
                }
                return Ok(ts_types.join(" | "));
            }

            // Handle single type (but not "object" - that needs properties/additionalProperties check)
            if let Some(type_str) = type_value.as_str() {
                if type_str != "object" {
                    return Ok(json_type_to_ts(type_str));
                }
                // For "object" type, fall through to check for properties/additionalProperties
            }
        }

        // Handle object with properties
        if let Some(_properties) = schema.get("properties") {
            // Generate inline object type
            return self.generate_inline_object_type(schema, defs);
        }

        // Handle object with additionalProperties
        if let Some(additional_props) = schema.get("additionalProperties") {
            // If additionalProperties is a schema, generate Record<string, T>
            if additional_props.is_object() {
                let value_type = self.schema_to_ts_type(additional_props, defs)?;
                return Ok(format!("Record<string, {}>", value_type));
            }
            // If additionalProperties is true, use Record<string, any>
            if additional_props.as_bool() == Some(true) {
                return Ok("Record<string, any>".to_string());
            }
        }

        // If we have type: "object" but no properties or additionalProperties, use Record<string, any>
        if let Some(type_value) = schema.get("type") {
            if type_value == "object" {
                return Ok("Record<string, any>".to_string());
            }
        }

        Ok("any".to_string())
    }
}

fn json_type_to_ts(json_type: &str) -> String {
    match json_type {
        "string" => "string",
        "integer" | "number" => "number",
        "boolean" => "boolean",
        "null" => "null",
        "object" => "Record<string, any>",
        "array" => "any[]",
        _ => "any",
    }
    .to_string()
}

/// Collects fields marked with !sdk:skip-formatting from schema definitions
fn collect_skip_formatting_fields(defs: &Map<String, Value>) -> Result<std::collections::HashMap<String, Vec<String>>> {
    use std::collections::HashMap;

    let mut result: HashMap<String, Vec<String>> = HashMap::new();

    for (type_name, schema) in defs {
        if let Some(properties) = schema.get("properties") {
            if let Some(props) = properties.as_object() {
                let mut skip_fields = Vec::new();

                for (field_name, field_schema) in props {
                    if let Some(description) = field_schema.get("description") {
                        if let Some(desc_str) = description.as_str() {
                            if desc_str.contains("!sdk:skip-formatting") {
                                // Convert field name from API format (hyphens) to TS format (underscores)
                                let ts_field_name = field_name.replace('-', "_").replace('.', "_");
                                skip_fields.push(ts_field_name);
                            }
                        }
                    }
                }

                if !skip_fields.is_empty() {
                    skip_fields.sort();
                    result.insert(type_name.clone(), skip_fields);
                }
            }
        }
    }

    Ok(result)
}

fn generate_client(api_schema: &ApiSchema) -> Result<String> {
    let mut src = String::new();
    src.push_str("// Auto-generated TypeScript API client\n");
    src.push_str("// Do not edit this file directly\n\n");
    src.push_str("import * as types from './types';\n\n");

    // Add client constants
    src.push_str("export const CLIENT_COMPAT_VERSION = '1';\n\n");

    // Collect fields marked with !sdk:skip-formatting
    let skip_formatting_fields = collect_skip_formatting_fields(&api_schema.defs)?;

    // Add typed WebSocket stream classes
    src.push_str(
        r#"/**
 * Typed event handler for log streams
 */
export class LogStream {
  private ws: WebSocket;
  private listeners: {
    log: ((item: types.LogStreamItem) => void)[];
    error: ((error: Error) => void)[];
    close: (() => void)[];
  } = {
    log: [],
    error: [],
    close: [],
  };

  constructor(ws: WebSocket) {
    this.ws = ws;

    this.ws.addEventListener('message', (event) => {
      try {
        const data = typeof event.data === 'string' ? event.data : event.data.toString();
        const logItem = convertFromApiFormat(JSON.parse(data)) as types.LogStreamItem;
        this.listeners.log.forEach(fn => fn(logItem));
      } catch (err) {
        const error = err instanceof Error ? err : new Error(String(err));
        this.listeners.error.forEach(fn => fn(error));
      }
    });

    this.ws.addEventListener('error', (event) => {
      const error = new Error('WebSocket error');
      this.listeners.error.forEach(fn => fn(error));
    });

    this.ws.addEventListener('close', () => {
      this.listeners.close.forEach(fn => fn());
    });
  }

  on(event: 'log', handler: (item: types.LogStreamItem) => void): this;
  on(event: 'error', handler: (error: Error) => void): this;
  on(event: 'close', handler: () => void): this;
  on(event: string, handler: any): this {
    if (event in this.listeners) {
      (this.listeners as any)[event].push(handler);
    }
    return this;
  }

  off(event: 'log', handler: (item: types.LogStreamItem) => void): this;
  off(event: 'error', handler: (error: Error) => void): this;
  off(event: 'close', handler: () => void): this;
  off(event: string, handler: any): this {
    if (event in this.listeners) {
      const handlers = (this.listeners as any)[event];
      const index = handlers.indexOf(handler);
      if (index !== -1) {
        handlers.splice(index, 1);
      }
    }
    return this;
  }

  close(): void {
    this.ws.close();
  }

  get readyState(): number {
    return this.ws.readyState;
  }
}

"#,
    );

    // Generate map of types to fields that should skip formatting
    src.push_str("/**\n");
    src.push_str(" * Map of type names to fields that contain user-defined data\n");
    src.push_str(" * and should not have their contents recursively converted.\n");
    src.push_str(" * Generated from schema fields marked with !sdk:skip-formatting\n");
    src.push_str(" */\n");
    src.push_str("const SKIP_FORMATTING_FIELDS: Record<string, Set<string>> = {\n");

    let mut sorted_types: Vec<_> = skip_formatting_fields.keys().collect();
    sorted_types.sort();

    for type_name in sorted_types {
        if let Some(fields) = skip_formatting_fields.get(type_name) {
            src.push_str(&format!("  '{}': new Set([", type_name));
            src.push_str(&fields.iter().map(|f| format!("'{}'", f)).collect::<Vec<_>>().join(", "));
            src.push_str("]),\n");
        }
    }

    src.push_str("};\n\n");

    // Add generic helpers for converting between API format and TypeScript format
    src.push_str(
        r#"/**
 * Converts TypeScript format (underscore properties) to API format (hyphenated properties)
 * Used for sending requests to the API.
 * @param obj The object to convert
 * @param depth Current traversal depth (relative to the typed object)
 * @param typeName Optional type name for checking skip-formatting fields
 */
function convertToApiFormat(obj: any, depth: number = 0, typeName?: string): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(item => convertToApiFormat(item, depth + 1, typeName));
  }

  if (typeof obj === 'object' && obj.constructor === Object) {
    const result: any = {};
    const skipFields = typeName ? SKIP_FORMATTING_FIELDS[typeName] : undefined;

    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const apiKey = key.replace(/_/g, '-');
        // Don't recursively convert fields marked with !sdk:skip-formatting
        if (depth === 0 && skipFields?.has(key)) {
          result[apiKey] = obj[key];
        } else {
          result[apiKey] = convertToApiFormat(obj[key], depth + 1, typeName);
        }
      }
    }
    return result;
  }

  return obj;
}

/**
 * Converts API response format (hyphenated properties) to TypeScript (underscore properties)
 * Used for generic response handling.
 * @param obj The object to convert
 * @param depth Current traversal depth (relative to the typed object)
 * @param typeName Optional type name for checking skip-formatting fields
 */
function convertFromApiFormat(obj: any, depth: number = 0, typeName?: string): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(item => convertFromApiFormat(item, depth + 1, typeName));
  }

  if (typeof obj === 'object' && obj.constructor === Object) {
    const result: any = {};
    const skipFields = typeName ? SKIP_FORMATTING_FIELDS[typeName] : undefined;

    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const tsKey = key.replace(/-/g, '_');
        // Don't recursively convert fields marked with !sdk:skip-formatting
        if (depth === 0 && skipFields?.has(tsKey)) {
          result[tsKey] = obj[key];
        } else {
          result[tsKey] = convertFromApiFormat(obj[key], depth + 1, typeName);
        }
      }
    }
    return result;
  }

  return obj;
}

"#,
    );

    // Generate config interface
    src.push_str("export interface ApiClientConfig {\n");
    src.push_str("  baseUrl: string;\n");
    src.push_str("  token: string;\n");
    src.push_str("  fetch?: typeof fetch;\n");
    src.push_str("  WebSocket?: typeof WebSocket;\n");
    src.push_str("}\n\n");

    // Generate NamespaceParam type for method parameters
    src.push_str("export type NamespaceParam = string | null;\n\n");

    // Generate main ApiClient class
    src.push_str("export class ApiClient {\n");
    src.push_str("  private config: ApiClientConfig;\n");
    src.push_str("  private fetchFn: typeof fetch;\n");
    src.push_str("  private WebSocketImpl: typeof WebSocket;\n\n");

    src.push_str("  constructor(config: ApiClientConfig) {\n");
    src.push_str("    this.config = config;\n");
    src.push_str("    this.fetchFn = config.fetch || fetch;\n");
    src.push_str("    this.WebSocketImpl = config.WebSocket || WebSocket;\n");
    src.push_str("  }\n\n");

    // Generate service accessor methods
    for service in &api_schema.services {
        let service_client_name = format!("{}ApiClient", service.name);
        src.push_str(&format!(
            "  {}(): {} {{\n",
            service.tag, service_client_name
        ));
        src.push_str(&format!(
            "    return new {}(this.config, this.fetchFn, this.WebSocketImpl);\n",
            service_client_name
        ));
        src.push_str("  }\n\n");
    }

    src.push_str("}\n\n");

    // Generate individual service clients
    for service in &api_schema.services {
        let service_client_name = format!("{}ApiClient", service.name);

        src.push_str(&format!("export class {} {{\n", service_client_name));
        src.push_str("  private config: ApiClientConfig;\n");
        src.push_str("  private fetchFn: typeof fetch;\n");
        src.push_str("  private WebSocketImpl: typeof WebSocket;\n\n");

        src.push_str("  constructor(config: ApiClientConfig, fetchFn: typeof fetch, WebSocketImpl: typeof WebSocket) {\n");
        src.push_str("    this.config = config;\n");
        src.push_str("    this.fetchFn = fetchFn;\n");
        src.push_str("    this.WebSocketImpl = WebSocketImpl;\n");
        src.push_str("  }\n\n");

        // Generate methods for each service
        for method in &service.methods {
            if method.verb == ApiVerb::WebSocket {
                generate_ts_websocket_method(&mut src, service, method)?;
            } else {
                generate_ts_method(&mut src, service, method)?;
            }
        }

        src.push_str("}\n\n");
    }

    Ok(src)
}

fn generate_ts_method(
    src: &mut String,
    service: &crate::machinery::api_schema::ApiService,
    method: &ApiMethod,
) -> Result<()> {
    let method_name = &method.name;

    // Build method signature
    let mut params = Vec::new();

    let namespaced = service.namespaced || method.namespaced;
    let needs_namespace_param =
        namespaced && (method.verb == ApiVerb::Get || method.verb == ApiVerb::Delete);

    if needs_namespace_param {
        // For list operations, namespace can be null (list all namespaces)
        // For get/delete specific resources, namespace is required
        let is_list_operation = method_name == "list";
        let namespace_type = if is_list_operation {
            "NamespaceParam"
        } else {
            "string"
        };
        params.push(format!("namespace: {}", namespace_type));
    }

    if method
        .path
        .iter()
        .any(|s| matches!(s, ApiPathSegment::ResourceName))
    {
        params.push("name: string".to_string());
    }

    if let Some(request) = &method.request {
        match request {
            ApiRequest::SchemaDefinition { name } => {
                params.push(format!("{}: types.{}", to_camel_case(name), name));
            }
            ApiRequest::OptionalSchemaDefinition { name } => {
                params.push(format!("{}?: types.{}", to_camel_case(name), name));
            }
            ApiRequest::TaggedSchemaDefinition { name, .. } => {
                params.push(format!("{}: types.{}", to_camel_case(name), name));
            }
        }
    }

    let return_type = generate_ts_return_type(&method.response);

    src.push_str(&format!(
        "  async {}({}): Promise<{}> {{\n",
        method_name,
        params.join(", "),
        return_type
    ));

    // Build URL
    let url_parts: Vec<String> = method
        .path
        .iter()
        .map(|segment| match segment {
            ApiPathSegment::Static { value } => value.to_string(),
            ApiPathSegment::ResourceName => "${name}".to_string(),
        })
        .collect();

    src.push_str(&format!(
        "    const url = `${{this.config.baseUrl}}/{}`;\n",
        url_parts.join("/")
    ));

    // Build headers
    src.push_str("    const headers: Record<string, string> = {\n");
    src.push_str("      'x-ignition-token': this.config.token,\n");
    src.push_str("      'x-ignition-compat': CLIENT_COMPAT_VERSION,\n");
    src.push_str("      'Content-Type': 'application/json',\n");
    src.push_str("    };\n\n");

    // Add namespace header if needed
    if needs_namespace_param {
        let is_list_operation = method_name == "list";
        if is_list_operation {
            // For list operations, namespace is nullable
            src.push_str("    if (namespace !== null) {\n");
            src.push_str("      headers['x-ignition-namespace'] = namespace;\n");
            src.push_str("    }\n\n");
        } else {
            // For get/delete operations, namespace is always a string
            src.push_str("    headers['x-ignition-namespace'] = namespace;\n\n");
        }
    }

    // Build fetch options
    let verb = match method.verb {
        ApiVerb::Get => "GET",
        ApiVerb::Put => "PUT",
        ApiVerb::Delete => "DELETE",
        ApiVerb::WebSocket => unreachable!(),
    };

    src.push_str("    const options: RequestInit = {\n");
    src.push_str(&format!("      method: '{}',\n", verb));
    src.push_str("      headers,\n");

    // Add body if needed
    if let Some(request) = &method.request {
        let (param_name, type_name) = match request {
            ApiRequest::SchemaDefinition { name }
            | ApiRequest::OptionalSchemaDefinition { name }
            | ApiRequest::TaggedSchemaDefinition { name, .. } => {
                (to_camel_case(name), name.clone())
            }
        };

        // For versioned resources, unwrap and convert the inner V1 object, then rewrap
        let conversion_expr = if service.versioned {
            let resource_key = format!("{}.v1", type_name.to_lowercase());
            let v1_type_name = format!("{}V1", type_name);
            format!(
                "{{ '{resource_key}': convertToApiFormat({param_name}['{resource_key}'], 0, '{v1_type_name}') }}",
                resource_key = resource_key,
                param_name = param_name,
                v1_type_name = v1_type_name
            )
        } else {
            // Non-versioned request types - pass through as-is
            param_name.clone()
        };

        if matches!(request, ApiRequest::OptionalSchemaDefinition { .. }) {
            src.push_str(&format!(
                "      body: {} ? JSON.stringify({}) : undefined,\n",
                param_name, conversion_expr
            ));
        } else {
            src.push_str(&format!(
                "      body: JSON.stringify({}),\n",
                conversion_expr
            ));
        }
    }

    src.push_str("    };\n\n");

    // Make request
    src.push_str("    const response = await this.fetchFn(url, options);\n\n");

    // Handle response
    src.push_str("    if (!response.ok) {\n");
    src.push_str("      const text = await response.text();\n");
    src.push_str("      throw new Error(`API error: ${response.status} ${text}`);\n");
    src.push_str("    }\n\n");

    if method.response.is_some() {
        // For versioned resource responses, pass type information for proper field handling
        let is_versioned_resource = service.versioned && (method.name == "get" || method.name == "list");

        src.push_str("    const data = await response.json();\n");

        if is_versioned_resource {
            let v1_type = format!("{}V1", service.name);
            if method.name == "list" {
                // List returns array of tuples: [[ResourceV1, Status], ...]
                src.push_str(&format!(
                    "    return data.map((item: any) => [convertFromApiFormat(item[0], 0, '{}'), convertFromApiFormat(item[1])]);\n",
                    v1_type
                ));
            } else {
                // Get returns tuple: [ResourceV1, Status]
                src.push_str(&format!(
                    "    return [convertFromApiFormat(data[0], 0, '{}'), convertFromApiFormat(data[1])];\n",
                    v1_type
                ));
            }
        } else {
            // Generic conversion for non-versioned resources
            src.push_str("    return convertFromApiFormat(data);\n");
        }
    } else {
        src.push_str("    return;\n");
    }

    src.push_str("  }\n\n");

    Ok(())
}

fn generate_ts_websocket_method(
    src: &mut String,
    service: &crate::machinery::api_schema::ApiService,
    method: &ApiMethod,
) -> Result<()> {
    let method_name = &method.name;

    // Build method signature
    let mut params = Vec::new();

    let namespaced = service.namespaced || method.namespaced;
    if namespaced {
        params.push("namespace: NamespaceParam".to_string());
    }

    if let Some(request) = &method.request {
        match request {
            ApiRequest::SchemaDefinition { name } => {
                params.push(format!("{}: types.{}", to_camel_case(name), name));
            }
            ApiRequest::OptionalSchemaDefinition { name } => {
                params.push(format!("{}?: types.{}", to_camel_case(name), name));
            }
            ApiRequest::TaggedSchemaDefinition { name, .. } => {
                params.push(format!("{}: types.{}", to_camel_case(name), name));
            }
        }
    }

    // Use LogStream for stream_logs, raw WebSocket for others (like exec)
    let return_type = if method_name == "stream_logs" {
        "LogStream"
    } else {
        "WebSocket"
    };

    src.push_str(&format!(
        "  {}({}): {} {{\n",
        method_name,
        params.join(", "),
        return_type
    ));

    // Build URL path
    let url_parts: Vec<String> = method
        .path
        .iter()
        .map(|segment| match segment {
            ApiPathSegment::Static { value } => value.to_string(),
            ApiPathSegment::ResourceName => "${name}".to_string(),
        })
        .collect();

    // Convert http(s):// to ws(s)://
    src.push_str("    const wsUrl = this.config.baseUrl.replace(/^http/, 'ws');\n");
    src.push_str(&format!(
        "    let url = `${{wsUrl}}/{}`;\n",
        url_parts.join("/")
    ));

    // Add request params as URL query parameters (if there's a request body)
    if let Some(request) = &method.request {
        let param_name = match request {
            ApiRequest::SchemaDefinition { name }
            | ApiRequest::OptionalSchemaDefinition { name }
            | ApiRequest::TaggedSchemaDefinition { name, .. } => to_camel_case(name),
        };

        // WebSocket params are serialized as-is (no conversion needed for utility types like LogStreamParams)
        let source_object = param_name.clone();

        if matches!(request, ApiRequest::OptionalSchemaDefinition { .. }) {
            src.push_str(&format!("    if ({}) {{\n", param_name));
            src.push_str("      const params = new URLSearchParams();\n");
            src.push_str(&format!(
                "      for (const [key, value] of Object.entries({})) {{\n",
                source_object
            ));
            src.push_str("        if (value != null) {\n");
            src.push_str("          params.set(key, String(value));\n");
            src.push_str("        }\n");
            src.push_str("      }\n");
            src.push_str("      const queryString = params.toString();\n");
            src.push_str("      if (queryString) {\n");
            src.push_str("        url += `?${queryString}`;\n");
            src.push_str("      }\n");
            src.push_str("    }\n\n");
        } else {
            src.push_str("    const params = new URLSearchParams();\n");
            src.push_str(&format!(
                "    for (const [key, value] of Object.entries({})) {{\n",
                source_object
            ));
            src.push_str("      if (value != null) {\n");
            src.push_str("        params.set(key, String(value));\n");
            src.push_str("      }\n");
            src.push_str("    }\n");
            src.push_str("    const queryString = params.toString();\n");
            src.push_str("    if (queryString) {\n");
            src.push_str("      url += `?${queryString}`;\n");
            src.push_str("    }\n\n");
        }
    }

    // Create WebSocket with proper protocols to support custom headers
    // Note: Browser WebSocket API doesn't support custom headers, but some implementations do
    src.push_str("    const ws = new this.WebSocketImpl(url, {\n");
    src.push_str("      headers: {\n");
    src.push_str("        'x-ignition-token': this.config.token,\n");
    src.push_str("        'x-ignition-compat': CLIENT_COMPAT_VERSION,\n");

    if namespaced {
        src.push_str(
            "        ...(namespace !== null ? { 'x-ignition-namespace': namespace } : {}),\n",
        );
    }

    src.push_str("      },\n");
    src.push_str("    } as any);\n\n");

    // Wrap in LogStream for stream_logs, return raw WebSocket for exec
    if method_name == "stream_logs" {
        src.push_str("    return new LogStream(ws);\n");
    } else {
        src.push_str("    return ws;\n");
    }
    src.push_str("  }\n\n");

    Ok(())
}

fn generate_ts_return_type(response: &Option<ApiResponse>) -> String {
    match response {
        Some(ApiResponse::SchemaDefinition { list, name, .. }) => {
            if *list {
                format!("types.{}[]", name)
            } else {
                format!("types.{}", name)
            }
        }
        Some(ApiResponse::TupleSchemaDefinition { list, names, .. }) => {
            let tuple_type = names
                .iter()
                .map(|name| format!("types.{}", name))
                .collect::<Vec<_>>()
                .join(", ");

            if *list {
                format!("[{}][]", tuple_type)
            } else {
                format!("[{}]", tuple_type)
            }
        }
        Some(ApiResponse::RawSocket) => "WebSocket".to_string(),
        None => "void".to_string(),
    }
}

fn to_camel_case(s: &str) -> String {
    if s.is_empty() {
        return s.to_string();
    }

    let mut result = String::new();
    let mut chars = s.chars();

    if let Some(first) = chars.next() {
        result.push(first.to_lowercase().next().unwrap());
        result.extend(chars);
    }

    result
}
